\documentclass[11pt]{article}

% usepackage[margin = 1in]{geometry}
\usepackage{fullpage}              
\usepackage{graphicx}              
\usepackage{amsmath}               
\usepackage{amsfonts}              
\usepackage{amsthm}                
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{url}
\usepackage{color}
\usepackage{hyperref}
\usepackage{algpseudocode}
\usepackage[plain]{algorithm}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{authblk}
\usepackage{tcolorbox}
\usepackage{mathtools}
\usepackage{bm}
\usepackage{dsfont}
%\usepackage[T1]{fontenc}
%\usepackage{libertine}
%\usepackage[libertine]{newtxmath}


\hypersetup{
	unicode = true,
	colorlinks = true,
	citecolor = blue,
	filecolor = blue,
	linkcolor = blue,
	urlcolor = blue,
	pdfstartview = {FitH},
}

% theorem environments
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{example}[theorem]{Example}
\newtheorem*{remark}{Remark}
\newtheorem{note}{Note}
\newtheorem*{problem}{Problem}
\newtheorem*{fact}{Fact}



\algrenewcommand{\Require}{\item[\textbf{Input:}]}
\algrenewcommand{\Ensure}{\item[\textbf{Output:}]}

\newcommand{\wrt}{\vdash} 
\newcommand{\tildO}{\tilde{O}}

% roman numerals
\newcommand{\romnum}[1]{\romannumeral #1}
\newcommand{\Romnum}[1]{\uppercase\expandafter{\romannumeral #1}}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\DeclareMathOperator{\fieldchar}{char} % characteristic of a field
\DeclareMathOperator{\groupofend}{End} % endomorphism ring
\DeclareMathOperator{\trace}{Tr} % finite field trace
\DeclareMathOperator{\gal}{Gal} % Galois group
\DeclareMathOperator{\order}{ord} % order of an element
\DeclareMathOperator{\lcm}{lcm} % least common multiple
\DeclareMathOperator{\divisor}{div} % divisor on a curve
\DeclareMathOperator{\supp}{supp} % support of a divisor
\DeclareMathOperator{\norm}{N} % norm
\DeclareMathOperator{\negl}{negl} % norm
\DeclareMathOperator{\Res}{Res}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\minpoly}{minpoly}
\DeclareMathOperator{\loglog}{loglog}
\DeclareMathOperator{\polylog}{polylog}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\rev}{rev}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\qft}{F}
\DeclareMathOperator{\E}{\mathbb{E}}


\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\ldbrac}{\lvert}{\rangle}
\DeclarePairedDelimiter{\rdbrac}{\langle}{\rvert}
\DeclarePairedDelimiter{\lrang}{\langle}{\rangle}
\DeclarePairedDelimiter{\opnorm}{\lVert}{\rVert}


\def\Q{\ensuremath{\mathbb{Q}}}
\def\C{\ensuremath{\mathbb{C}}}
\def\K{\ensuremath{\mathbb{K}}}
\def\N{\ensuremath{\mathbb{N}}}
\def\R{\ensuremath{\mathbb{R}}}
\def\Z{\ensuremath{\mathbb{Z}}}
\def\F{\ensuremath{\mathbb{F}}}
\def\P{\ensuremath{\mathbb{P}}}
\def\MM{\ensuremath{\mathsf{M}}}
\def\CC{\ensuremath{\mathsf{C}}}
\def\lwe{\ensuremath{\mathsf{LWE}}}
\def\edcp{\ensuremath{\mathsf{EDCP}}}
\def\euler{\ensuremath{\varphi}}



\title{Quantum Learning With Errors}

\author{
	%% Javad Oilskin\thanks{Department of Computer Science, Ryerson University,
	%% (\tt{javad.doliskani@ryerson.ca}).}
}

\date{}
\setlength{\parindent}{0pt}
\sloppy




\begin{document}
\maketitle





%% ///////////////////////////////////////////////////////



\section{Preliminaries}


In this section, we review some basic concepts and notations of quantum computing and the learning with error (LWE) problem. 

Let $n \ge 1$, and $q \ge 2$ be integers, and let $\chi$ be a probability distribution over $\Z$. For a random fixed $\bm{s} \in \Z_q^n$, denote by $A_{\bm{s}, \chi}$ the probability distribution over $\Z_q^n \times \Z_q$ defined as follows: choose $\bm{a} \in \Z_q^n$ uniformly at random, choose $e$ from according to $\chi$ and output  $(\bm{a}, \lrang{\bm{a}, \bm{s}} + e)$.
\begin{definition}[LWE, Search]
The search-$\lwe_{n, q, \chi}$ is the problem of recovering $\bm{s}$ given samples from the distribution $A_{\bm{s}, \chi}$. An algorithm $Q$ is said to solve $\lwe_{n, q, \chi}$ if $Q$  outputs $\bm{s}$ with probability at least $1 / \poly(n\log q)$ and has running time at most $\poly(n \log q)$.
\end{definition}
\begin{definition}[LWE, Decision]
    The decision-$\lwe_{n, q, \chi}$ problem is to distinguish between the distribution $A_{\bm{s}, \chi}$ and the uniform distribution over $\Z_q^n \times \Z_q$. An algorithm $Q$ is said to solve the desicion-$\lwe_{n, q, \chi}$ if it succeeds with advantage at least $1 / \poly(n\log q)$ and has running time at most $\poly(n\log q)$. 
\end{definition}
Let $n \ge 1$ and $q \ge 2$ be as above and let $r < q$ be a positive integer. Let $\Sigma = \Z_r \times \Z_q^n$ and define the complex Euclidean space $\mathcal{X} = \C^\Sigma$. For a fixed $\bm{s} \in \Z_q^n$ define the probability distribution $B_{\bm{s}, r}$ over a finite subset of $\mathcal{X}$ as follows: choose $\bm{x} \in \Z_q^n$ uniformly at random and output the state
\[ \ldbrac{\phi_{\bm{s}, r}(\bm{x})} = \frac{1}{\sqrt{r}} \sum_{j = 0}^{r - 1}\ldbrac{j}\ldbrac{\bm{x} + j\bm{s}}. \]
Since $\bm{s}$ is fixed and $\bm{x}$ is uniformly random and unknown, the quantum system corresponding to the state $\ldbrac{\phi_{\bm{s}, r}(\bm{x})}$ is described by the density operator
\[ \rho_{\bm{s}, r} = \frac{1}{q^n} \sum_{\bm{x} \in \Z_q^n} \ldbrac{\phi_{\bm{s}, r}(\bm{x})} \rdbrac{\phi_{\bm{s}, r}(\bm{x})}. \]
Therefore, the output of the distribution $B_{\bm{s}, r}$ is always described the density operator $\rho_{\bm{s}, r}$. In other words, the distribution $B_{\bm{s}, r}$ provides \textit{copies} of the state $\rho_{\bm{s}, r}$.
\begin{definition}[EDCP, Search]
    Let $n$, $q$ and $r$ be defined as above. The search-$\edcp_{n, q, r}$ is the problem of recovering $\bm{s}$ given samples from the distribution $B_{\bm{s}, r}$. A quantum algorithm $Q$ is said to solve $\edcp_{n, q, r}$ if it outputs $\bm{s}$ with probability at least $1 / \poly(n\log q)$ and has running time at most $\poly(n\log q)$.
\end{definition}
\begin{definition}[\cite{watrous2009zero}]
    Let $A, B$ be probability distributions on a finite subset of a complex Euclidean space $\mathcal{X}$. Then $A$ is said to be $(s, \epsilon)$-distinguishable from $B$ if there is a quantum measurement circuit $Q$ of size $s$ such that
    \[ \abs*{ \Pr_{\rho \in A}[Q(\rho) = 1] - \Pr_{\rho \in B}[Q(\rho) = 1] } \ge \epsilon. \]
\end{definition} 
Two distributions $A, B$ are $(s, \epsilon)$-indistinguishable if they are not $(s, \epsilon)$-distinguishable.
\begin{definition}
    For each $n \in \N$, let $A_n$ and $B_n$ be probability distributions on a finite subset of a complex Euclidean space $\mathcal{X}_n$. Then the two ensembles $\{ A_n \}_{n \in \N}$ and $\{ B_n \}_{n \in \N}$ are said to be polynomially quantum indistinguishable if for all polynomially bounded functions $s, p: \N \rightarrow \N$, the distributions $A_n$ and $B_n$ are $(s(n), 1 / p(n))$-indistinguishable for almost all $n \in \N$.
\end{definition}
Two ensembles are called quantum computationally indistinguishable if they are polynomially quantum indistinguishable. The advantage of a polynomial-time quantum algorithm $Q$ in distinguishing between the distributions $A_n$ and $B_n$ is defined as
\[ \delta_Q(A_n, B_n) = \abs*{ \Pr_{\rho \in A_n}[Q(\rho) = 1] - \Pr_{\rho \in B_n}[Q(\rho) = 1] }. \]
Two ensembles $\{ A_n \}_{n \in \N}$ and $\{ B_n \}_{n \in \N}$ are then quantum computationally indistinguishable if $\delta_Q(A_n, B_n) = \negl(n)$ for all such $Q$ and almost all $n$. 
\begin{definition}[EDCP, Decision]
    \label{def:d-edcp}
    Let $n$, $q$ and $r$ be defined as above. Define the probability distribution $U_{r}$ over a finite subset of $\mathcal{X}$ by choosing $(j, \bm{x}) \in \Z_r \times \Z_q^n$ uniformly at random and outputting the state $\ldbrac{j}\ldbrac{\bm{x}}$. The decision-$\edcp_{n, q, r}$ is the problem of distinguishing between the distributions $B_{\bm{s}, r}$ and $U_r$.
\end{definition}
A quantum algorithm $Q$ is said to solve the decision-$\edcp_{n, q}^\ell$ if it succeeds with advantage at least $1 / \poly(n\log q)$ and has running time at most $\poly(n\log q)$. The density operator corresponding to the output of the distribution $U_r$ in Definition \ref{def:d-edcp} is
\[ \rho = \frac{1}{rq^n} \sum_{j = 0}^{r - 1} \sum_{\bm{x} \in \Z_q^n}  \ldbrac{j}\ldbrac{\bm{x}} \rdbrac{j}\rdbrac{\bm{x}} = \mathds{1}_{\mathcal{X}}. \]
Therefore, decision-$\edcp_{n, q, r}$ is the problem of distinguishing between the same number of copies of the states $\rho_{\bm{s}, r}$ and $\mathds{1}_{\mathcal{X}}$. 


%% ///////////////////////////////////////////////////////



\section{Search to Decision Reduction}





%% ///////////////////////////////////////////////////////



\section{EDCP for \boldmath${q = 2^k}$\unboldmath}


In this section we assume $q$ and $r$ are powers of $2$. Let $\bm{s} \in \Z_q^n$ be fixed and let $b \in \{ 0, 1 \}$. Suppose that a quantum system is in the state 
\[ \ldbrac{\phi_{\bm{s}, \bm{x}, b}} = \frac{1}{\sqrt{r}} \sum_{j = 0}^{r - 1} (-1)^{bj}\ldbrac{j}\ldbrac{\bm{x} + j\bm{s}} \]
for some uniformly random $\bm{x} \in \Z_q$. Then the  system is described by the density operator  
\[ \Phi_{\bm{s}, b} = \frac{1}{q^n} \sum_{\bm{x} \in \Z_q^n} \ldbrac{\phi_{\bm{s}, \bm{x}, b}} \rdbrac{\phi_{\bm{s}, \bm{x}, b}}. \]
\begin{definition}[Search]
    Let $\bm{s} \in \Z_q^n$, and let $\ell: \N \rightarrow \N$ be polynomially bounded. Given $\ell(n)$ copies of the state $\Phi_{\bm{s}, 0}$, i.e., given $\Phi_{\bm{s}, 0}^{\otimes \ell(n)}$, find $\bm{s}$.
\end{definition}
\begin{definition}[Decision]
    Let $\bm{s} \in \Z_q^n$, and let $\ell: \N \rightarrow \N$ be polynomially bounded. Distinguish with non-negligible advantage between the two ensembles $\{ \Phi_{\bm{s}, 0}^{\otimes \ell(n)} \}_{n \in \N}$ and $\{ \Phi_{\bm{s}, 1}^{\otimes \ell(n)} \}_{n \in \N}$.
\end{definition}
\begin{theorem}[Search to Decision]
    If there is a polynomial time quantum algorithm for the decision problem then there is a polynomial time quantum algorithm for the search problem.
\end{theorem}
\begin{proof}
    Assume there is a quantum polynomial time algorithm $Q$ for the Decision problem. Let $\tilde{\Phi}_{\bm{s}, b} = \Phi_{\bm{s}, b}^{\otimes \ell(n)}$. Fix an arbitrary $n$ for which 
    \[ \Pr[ Q(\tilde{\Phi}_{\bm{s}, 1}) = 1 ] - \Pr[ Q(\tilde{\Phi}_{\bm{s}, 0}) = 1 ] \ge \frac{1}{p(n)} \]
    for some polynomial $p(n)$. We will construct an algorithm $W$ that computes $\bm{s}$ with high probability. Let $\bm{s} = (s_1, \dots, s_n)$. We show how to compute $s_1$, the other values $s_i$, $2 \le i \le n$, can be computed in a similar way. The strategy is to determine $s_1$ one bit at a time.

    Let $m = 2np(n)^2$ and obtain $2m$ copies of the state $\tilde{\Phi}_{\bm{s}, 0}$ stored in two registers $R = \tilde{\Phi}_{\bm{s}, 0} \otimes \cdots \otimes \tilde{\Phi}_{\bm{s}, 0}$ and $S = \tilde{\Phi}_{\bm{s}, 0} \otimes \cdots \otimes \tilde{\Phi}_{\bm{s}, 0}$. For an arbitrary $\bm{x} = (x_1, \dots, x_n)$, define the following unitary
    \[ U_1 \ldbrac{j}\ldbrac{\bm{x} + j\bm{s}} = (-1)^{x_1 + js_1} \ldbrac{j}\ldbrac{\bm{x} + j\bm{s}}. \]
    Ignoring the global phase $(-1)^{x_1}$, $U_1$ acts on the state $\ldbrac{\phi_{\bm{s}, \bm{x}, 0}}$ as follows
    \[ U_1 \ldbrac{\phi_{\bm{s}, \bm{x}, 0}} = \frac{1}{\sqrt{r}} \sum_{j = 0}^{r - 1} (-1)^{js_1}\ldbrac{j}\ldbrac{\bm{x} + j\bm{s}}. \]
    This means we have
    \begin{equation}
        \label{equ:u1}
        U_1^{\otimes \ell(n)} \tilde{\Phi}_{\bm{s}, 0} (U_1^*)^{\otimes \ell(n)} =
        \begin{cases}
            \tilde{\Phi}_{\bm{s}, 0} & \text{if } s_1 \text{ is even} \\
            \tilde{\Phi}_{\bm{s}, 1} & \text{if } s_1 \text{ is odd}.
        \end{cases}
    \end{equation}
    If we apply $U_1^{\otimes \ell(n)}$ to all the states $\tilde{\Phi}_{\bm{s}, 0}$ in $S$ we obtain the state $S_c = \tilde{\Phi}_{\bm{s}, c} \otimes \cdots \otimes \tilde{\Phi}_{\bm{s}, c}$ where $c = s_1 \mod 2$. Now, $W$ runs the algorithm $Q$ on all the states in the two registers $R$ and $S_c$. Let $X_i$ and $Y_i$, $1 \le i \le m$, be random variables representing the output of $Q$ on the states $\tilde{\Phi}_{\bm{s}, c}$ in $S_c$ and the states $\tilde{\Phi}_{\bm{s}, 0}$ in $R$, respectively. Let $Z = \sum_{i = 1}^m (X_i - Y_i)$. If $Z \ge np(n)$ then $W$ outputs $1$, otherwise it outputs $0$. For simplicity, we replace $Y_i$ by $-Y_i$ and assume that $Y_i \in \{ -1, 0 \}$. If $c = 1$ we have
    \begin{align*}
        \Pr[ Z \le np(n) ]
        & = \Pr[ Z \le \frac{m}{p(n)} - np(n) ] \\
        & \le \Pr[ Z - m(\Pr[ Q(\tilde{\Phi}_{\bm{s}, 1}) = 1 ] - \Pr[ Q(\tilde{\Phi}_{\bm{s}, 0}) = 1]) < -np(n) ] \\
        & = \Pr[ Z - \E[Z] \le -np(n) ] \\
        & \le 2^{-n / 2}
    \end{align*}
    If $c = 0$ then $\E[Z] = 0$ and
    \begin{align*}
        \Pr[ Z \ge np(n) - 1 ]
        & = \Pr[ Z -\E[Z] \ge np(n) - 1 ] \\
        & \le e^{-(np(n) - 1)^2 / m} \\
        & \le 2^{-\frac{n}{2}(1 - o(1))}.
    \end{align*}
    Therefore, $W$ outputs the least significant bit of $s_1$ with probability exponentially close to $1$. Assume that we have already computed the first $k$ bits $b_0, \dots, b_{k - 1}$ of $s_1$, and let $\tilde{s}_1 = b_{k - 1}2^{k - 1} + \cdots + b_12^1 + b_0$. Define the unitary
    \[ U_{k + 1} \ldbrac{j}\ldbrac{\bm{x} + j\bm{s}} = \omega_{2^{k + 1}}^{x_1 + js_1} \omega_{2^{k + 1}}^{-j\tilde{s}_1} \ldbrac{j}\ldbrac{\bm{x} + j\bm{s}}. \]
    Then the actions of $U_{k + 1}$ on the state $\tilde{\Phi}_{\bm{s}, 0}$ is similar to \eqref{equ:u1}. More precisely,
    \[
    U_{k + 1}^{\otimes \ell(n)} \tilde{\Phi}_{\bm{s}, 0} (U_{k + 1}^*)^{\otimes \ell(n)} =
    \begin{cases}
        \tilde{\Phi}_{\bm{s}, 0} & \text{if the } k\text{-th bit of } s_1 \text{ is } 0 \\
        \tilde{\Phi}_{\bm{s}, 1} & \text{if the } k\text{-th bit of } s_1 \text{ is } 1
    \end{cases}
    \]
    Repeating the above process with $U_{k + 1}$, $W$ determines the $(k + 1)$-th bit of $s_1$ with high probability. All the bits of $s_1$ are computed this way.
\end{proof}



%% ///////////////////////////////////////////////////////



\section{Quantum public key system}


\textit{Key generation:}

\begin{enumerate}[topsep = 1pt, itemsep = 1pt, parsep = 1pt]
\item Select $\bm{x} \in \Z_q^n$ uniformly at random.
\item Apply $\qft_r \otimes \mathds{1}$ to the register $\ldbrac{0} \ldbrac{\bm{x}}$ to obtain the state $\frac{1}{\sqrt{r}} \sum_{j = 0}^{r - 1} \ldbrac{j} \ldbrac{\bm{x}}$.
\item Apply the the operation $\ldbrac{j}\ldbrac{\bm{x}} \mapsto \ldbrac{j}\ldbrac{\bm{x} + j\bm{s}}$ to obtain the state $\ldbrac{\phi_{\bm{s}, \bm{x}, 0}} = \frac{1}{\sqrt{r}} \sum_{j = 0}^{r - 1} \ldbrac{j} \ldbrac{\bm{x} + j\bm{s}}$
\item Publish the state $\ldbrac{\phi_{\bm{s}, \bm{x}, 0}}$.     
\end{enumerate}

\vspace*{5mm}

\textit{Encryption:}

\begin{enumerate}[topsep = 1pt, itemsep = 1pt, parsep = 1pt]
\item Alice obtains a copy of Bob's public keys $\Phi_{\bm{s}, 0}$.
\item To encrypt a bit $b \in \{ 0, 1 \}$, Alice performs the unitary $U: \ldbrac{j}\ldbrac{\bm{y}} \mapsto (-1)^{bj}\ldbrac{j}\ldbrac{\bm{y}}$ on $\Phi_{\bm{s}, 0}$ to obtain the state $\Phi_{\bm{s}, b}$.
\item The state $\Phi_{\bm{s}, b}$ is sent to Bob.
\end{enumerate}

\vspace*{5mm}

\textit{Decryption:}
On receiving the encrypted state $\Phi_{\bm{s}, b}$, Bob perform the following:
\begin{enumerate}[topsep = 1pt, itemsep = 1pt, parsep = 1pt]
\item Apply the the unitary $U: \ldbrac{j}\ldbrac{\bm{y}} \mapsto \ldbrac{j}\ldbrac{\bm{y} - j\bm{s}}$ to $\Phi_{\bm{s}, b}$.
\item Discard the second register.
\item Apply $\qft_r$ and measure.
\item If the measurement result is 0 then output 0, otherwise output 1.
\end{enumerate}

\paragraph{Correctness.} 
Given the encrypted state $\Phi_{\bm{s}, b}$, the decryption steps are as follows
\begin{align*}
    \Phi_{\bm{s}, b}
    & \mapsto U \frac{1}{q^n} \sum_{\bm{x} \in \Z_q^n} \ldbrac{\phi_{\bm{s}, \bm{x}, b}} \rdbrac{\phi_{\bm{s}, \bm{x}, b}} U^* & (\text{apply } U)\\
    & = \frac{1}{q^n} \sum_{\bm{x} \in \Z_q^n} \frac{1}{r} \sum_{j = 0}^{r - 1} \sum_{k = 0}^{r - 1} (-1)^{b(j - k)}\ldbrac{k}\ldbrac{\bm{x}} \rdbrac{j}\rdbrac{\bm{x}} \\
    & = \frac{1}{r} \sum_{j = 0}^{r - 1} \sum_{k = 0}^{r - 1} (-1)^{b(j - k)}\ldbrac{k}\rdbrac{j} \otimes \frac{1}{q^n} \sum_{\bm{x} \in \Z_q^n} \ldbrac{\bm{x}}\rdbrac{\bm{x}} \\
    & \mapsto \frac{1}{r} \sum_{j = 0}^{r - 1} \sum_{k = 0}^{r - 1} (-1)^{b(j - k)}\ldbrac{k}\rdbrac{j} & (\text{discard the second register}) \\
    & \mapsto \qft_r \frac{1}{r} \sum_{j = 0}^{r - 1} \sum_{k = 0}^{r - 1} (-1)^{b(j - k)}\ldbrac{k}\rdbrac{j} \qft_r^* & (\text{apply quantum Fourier transfom})\\
    & = \ldbrac{br/2} \rdbrac{br/2}
\end{align*}
If $b = 0$ then the state of the system is $\ldbrac{0} \rdbrac{0}$, otherwise it is $\ldbrac{r / 2} \rdbrac{r / 2}$. 

\paragraph{Security.}


\bibliographystyle{plain}
\bibliography{references}
\end{document}



